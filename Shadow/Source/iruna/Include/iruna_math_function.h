//---------------------------------------------------------
// 
//	iruna_math_function.h
//	数学機能
//	作成日 11月13日
//	製作者 立川 翔野
// 
//---------------------------------------------------------
/*----多重インクルード防止-------------------------------------------------*/
#ifndef IRUNA_MATH_FUNCTION_H
#define IRUNA_MATH_FUNCTION_H

/*----インクルード-------------------------------------------------*/
#include "../Include/iruna_utility.h"
#include "../Include/iruna_vector3.h"
#include "../Include/iruna_matrix.h"

/*----データ型宣言-------------------------------------------------*/
namespace iruna
{
namespace math
{
/*----グローバル関数宣言-------------------------------------------------*/

//--------------------------------------------------------------------
// 
//	処理		:	3次元ベクトルの外積を求める
//	第1引数		:	[in]	vec1	-	1つ目のベクトル
//	第2引数		:	[inout]	vec2	-	2つ目のベクトル
//	戻り値		:	求めたベクトル
// 
//--------------------------------------------------------------------
Vector3	Cross( Vector3 vec1, Vector3 vec2 );

//--------------------------------------------------------------------
// 
//	処理		:	3次元ベクトルの内積を求める
//	第1引数		:	[in]	vec1	-	1つ目のベクトル
//	第2引数		:	[inout]	vec2	-	2つ目のベクトル
//	戻り値		:	求めたスカラー値
// 
//--------------------------------------------------------------------
float	Dot( Vector3 vec1, Vector3 vec2  );

//--------------------------------------------------------------------
// 
//	処理		:	3次元ベクトルの2乗の長さを求める
//	第1引数		:	[in]	vec1	-	正規化するベクトル
//	戻り値		:	ベクトルの2乗の長さ
// 
//--------------------------------------------------------------------
float	LengthSqrt( Vector3 vec );

//--------------------------------------------------------------------
// 
//	処理		:	3次元ベクトルの長さを求める
//	第1引数		:	[in]	vec1	-	長さを知りたいベクトル
//	戻り値		:	ベクトルの長さ
// 
//--------------------------------------------------------------------
float	Length( Vector3 vec );

//--------------------------------------------------------------------
// 
//	処理		:	3次元ベクトルを正規化する
//	第1引数		:	[in]	vec1	-	正規化するベクトル
//	戻り値		:	正規化されたベクトル
// 
//--------------------------------------------------------------------
Vector3 Normalize( Vector3 vec );

//--------------------------------------------------------------------
// 
//	処理		:	指定した位置とベクトル,時間でエルミネートスプライン曲線補間する
//	第1引数		:	[in]	pos1	-	始点
//	第2引数		:	[inout]	pos2	-	終点
//	第3引数		:	[in]	vec1	-	始点制御ベクトル
//	第4引数		:	[inout]	vec2	-	終点制御ベクトル
//	第5引数		:	[in]	time	-	補間する位置(0〜1)
//	戻り値		:	補間されたベクトル
// 
//--------------------------------------------------------------------
Vector3 HermiteLerp( Vector3 pos1, Vector3 pos2, Vector3 vec1, Vector3 vec2, float time );

//--------------------------------------------------------------------
// 
//	処理		:	指定したベクトルとベクトルを線形補間する
//					t = 補間位置 t0 = 始点ム t1 = 終点
//					time = ( t - t0) / ( t1 - t0 )
//	第1引数		:	[in]	vec1	-	始点ベクトル
//	第2引数		:	[in]	vec2	-	終点ベクトル
//	第3引数		:	[in]	time	-	補間位置(0〜1) 
//	戻り値		:	補間されたベクトル
// 
//--------------------------------------------------------------------
Vector3 Lerp( Vector3 vec1,Vector3 vec2, float time );

//--------------------------------------------------------------------
// 
//	処理		:	指定した行列と行列の線形補間して姿勢補間する
//					t = 補間位置 t0 = 始点 t1 = 終点
//					time = ( t - t0) / ( t1 - t0 )
//	第1引数		:	[in]	mat1	-	始点行列
//	第2引数		:	[in]	mat2	-	終点行列
//	第3引数		:	[in]	time	-	補間位置(0〜1)
//	戻り値		:	補間された行列
// 
//--------------------------------------------------------------------
Matrix MatrixInterp( Matrix mat1, Matrix mat2, float time );

//--------------------------------------------------------------------
// 
//	処理		:	指定したベクトルとベクトルを球面線形補間する
//					t = 補間位置 t0 = 始点 t1 = 終点
//					time = ( t - t0) / ( t1 - t0 )
//	第1引数		:	[in]	vec1	-	始点回転ベクトル
//	第2引数		:	[in]	vec2	-	終点回転ベクトル
//	第3引数		:	[in]	time	-	補間位置(0〜1) 
//	戻り値		:	補間されたベクトル
// 
//--------------------------------------------------------------------
Vector3 SphereLinear(  Vector3 vec1,Vector3 vec2, float time );

//--------------------------------------------------------------------
// 
//	処理		:	指定した行列と行列を球面線形補間で補間姿勢を求める
//					t = 補間位置 t0 = 始点 t1 = 終点
//					time = ( t - t0) / ( t1 - t0 )
//	第1引数		:	[in]	vec1	-	始点回転ベクトル
//	第2引数		:	[in]	vec2	-	終点回転ベクトル
//	第3引数		:	[in]	time	-	補間位置(0〜1) 
//	戻り値		:	補間された行列
// 
//--------------------------------------------------------------------
Matrix CalcInterPause(  Matrix mat1, Matrix mat2, float time );

}	//	math	end
}	//	iruna	end

#endif	//	IRUNA_MATH_FUNCTION_H	end